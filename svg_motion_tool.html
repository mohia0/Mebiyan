<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SVG Motion Tool</title>
    <style>
        :root {
            color-scheme: dark;
        }

        body {
            background-color: #111;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            gap: 1rem;
            font-family: 'Segoe UI', system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
            color: #f2f2f2;
        }

        #svg-container {
            display: flex;
            justify-content: center;
            align-items: center;
            width: min(80vw, 640px);
            cursor: grab;
            position: fixed;
            user-select: none;
            transform: translate(-50%, -50%);
            top: 50%;
            left: 50%;
        }

        #svg-container.dragging {
            cursor: grabbing;
            transition: none;
        }

        svg {
            max-width: 100%;
            height: auto;
            overflow: visible;
        }

        .controls {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.75rem;
            padding: 0.75rem 1.25rem;
            border-radius: 0;
            background: rgba(8, 8, 12, 0.96);
            box-shadow: 0 18px 45px rgba(0, 0, 0, 0.55);
            backdrop-filter: blur(14px);
            border: 1px solid rgba(120, 120, 140, 0.5);
            position: fixed;
            bottom: 1.5rem;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            flex-wrap: wrap;
            max-width: 95vw;
            min-height: 3.5rem;
        }

        button {
            background: #ffffff;
            border: 1px solid #000000;
            border-radius: 0;
            color: #000000;
            font-weight: 600;
            padding: 0.5rem 1rem;
            font-size: 0.8rem;
            cursor: pointer;
            letter-spacing: 0.04em;
            text-transform: uppercase;
            transition: transform 0.18s ease, box-shadow 0.18s ease, background 0.18s ease;
            box-shadow: none;
            white-space: nowrap;
            height: 2rem;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }

        button:disabled {
            cursor: not-allowed;
            background: #808080;
            color: #ffffff;
            border-color: #808080;
            box-shadow: none;
        }

        button:not(:disabled):hover {
            transform: translateY(-1px);
            background: #000000;
            color: #ffffff;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        #export-status {
            position: fixed;
            bottom: 0.4rem;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.7rem;
            min-height: 1.4em;
            color: #888888;
            letter-spacing: 0.12em;
            text-transform: uppercase;
            opacity: 0.85;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.75rem;
            color: #d8d8e0;
            white-space: nowrap;
            height: 100%;
            position: relative;
        }

        .control-group:not(:last-child)::after {
            content: '';
            position: absolute;
            right: -0.5rem;
            width: 1px;
            height: 60%;
            background: rgba(255, 255, 255, 0.1);
        }

        .control-label {
            text-transform: uppercase;
            letter-spacing: 0.12em;
            font-size: 0.7rem;
            opacity: 0.7;
            min-width: fit-content;
            flex-shrink: 0;
        }

        .slider-group {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .slider-group input[type="range"] {
            width: 100px;
            flex-shrink: 0;
        }

        .slider-value {
            font-variant-numeric: tabular-nums;
            font-size: 0.75rem;
            opacity: 0.75;
            min-width: 2.5rem;
            text-align: left;
            flex-shrink: 0;
        }

        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            height: 3px;
            border-radius: 0;
            background: #808080;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 12px;
            height: 12px;
            border-radius: 0;
            background: #000000;
            box-shadow: 0 0 0 2px #ffffff;
            cursor: pointer;
            border: 1px solid #000000;
        }

        input[type="range"]::-moz-range-thumb {
            width: 12px;
            height: 12px;
            border-radius: 0;
            background: #000000;
            box-shadow: 0 0 0 2px #ffffff;
            cursor: pointer;
            border: 1px solid #000000;
        }

        .toggle-group {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            cursor: pointer;
        }

        .toggle-group input[type="checkbox"] {
            accent-color: #000000;
            cursor: pointer;
            width: 1.1rem;
            height: 1.1rem;
            flex-shrink: 0;
        }

        .select-group {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .select-group select {
            padding: 0.35rem 0.8rem;
            padding-right: 2rem;
            border-radius: 0;
            border: 1px solid #000000;
            background: #ffffff;
            color: #000000;
            font-weight: 500;
            font-size: 0.75rem;
            cursor: pointer;
            min-width: 100px;
            height: 2rem;
            flex-shrink: 0;
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%23000000' d='M6 9L1 4h10z'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 0.5rem center;
            transition: background 0.18s ease, color 0.18s ease;
        }

        .select-group select:hover {
            background-color: #f5f5f5;
        }

        .select-group select:focus {
            outline: none;
            border-color: #000000;
            background-color: #ffffff;
        }

        .select-group select option {
            background: #ffffff;
            color: #000000;
            padding: 0.5rem;
        }

        .svg-preview-group {
            gap: 0.5rem;
            display: flex;
            align-items: flex-start;
            flex-wrap: wrap;
        }

        .svg-preview-container {
            display: flex;
            gap: 0.4rem;
            flex-wrap: wrap;
            max-width: 400px;
            overflow: visible;
            scrollbar-width: none;
            -ms-overflow-style: none;
        }

        .svg-preview-container::-webkit-scrollbar {
            display: none;
        }

        .svg-preview-item {
            width: 36px;
            height: 36px;
            border-radius: 0;
            border: 2px solid transparent;
            cursor: pointer;
            overflow: hidden;
            background: rgba(255, 255, 255, 0.05);
            transition: border-color 0.2s ease, transform 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 2px;
            flex-shrink: 0;
        }

        .svg-preview-item:hover {
            transform: scale(1.1);
            border-color: rgba(0, 0, 0, 0.5);
        }

        .svg-preview-item.active {
            border-color: #000000;
            background: rgba(0, 0, 0, 0.2);
        }

        .svg-preview-item object {
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .progress-container {
            position: fixed;
            top: 0.75rem;
            left: 50%;
            transform: translateX(-50%);
            width: 200px;
            height: 3px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 0;
            overflow: hidden;
            display: none;
            z-index: 15;
        }

        .screenshot-menu {
            position: fixed;
            bottom: 4.5rem;
            left: 50%;
            transform: translateX(-50%);
            display: none;
            flex-direction: column;
            gap: 0.25rem;
            z-index: 20;
            background: rgba(8, 8, 12, 0.98);
            border: 1px solid rgba(120, 120, 140, 0.5);
            padding: 0.5rem;
            box-shadow: 0 18px 45px rgba(0, 0, 0, 0.55);
        }

        .screenshot-menu button {
            width: 100%;
            min-width: 120px;
            margin: 0;
        }

        .screenshot-menu.show {
            display: flex;
        }

        .tool-title {
            position: fixed;
            top: 0.75rem;
            left: 0.9rem;
            font-size: 0.6rem;
            letter-spacing: 0.18em;
            text-transform: uppercase;
            font-weight: 500;
            pointer-events: none;
            transition: opacity 0.2s ease, color 0.2s ease;
        }

        .tool-title.light-bg {
            color: rgba(0, 0, 0, 0.65);
        }

        .tool-title.dark-bg {
            color: rgba(255, 255, 255, 0.55);
        }

        .studio-mark {
            position: fixed;
            top: 0.75rem;
            right: 0.9rem;
            font-size: 0.6rem;
            letter-spacing: 0.18em;
            text-transform: uppercase;
            font-weight: 500;
            text-decoration: none;
            cursor: pointer;
            transition: opacity 0.2s ease, color 0.2s ease;
        }

        .studio-mark.light-bg {
            color: rgba(0, 0, 0, 0.65);
        }

        .studio-mark.dark-bg {
            color: rgba(255, 255, 255, 0.55);
        }

        .studio-mark.light-bg:hover {
            color: rgba(0, 0, 0, 0.85);
        }

        .studio-mark.dark-bg:hover {
            color: rgba(255, 255, 255, 0.85);
        }

        .progress-bar {
            width: 0%;
            height: 100%;
            background: #000000;
            transition: width 0.2s ease;
        }
    </style>
</head>

<body>
    <div class="tool-title dark-bg"><span style="font-weight: 700;">MEBIYAN</span> GRAPHIC ELEMENT MOTION TOOL SYSTEM</div>
    <a
        class="studio-mark dark-bg"
        href="https://www.mohihassan.com"
        target="_blank"
        rel="noopener noreferrer"
    >
        Made with MOHI HASSAN DESIGN STUDIO
    </a>
    <div class="controls">
        <div class="control-group svg-preview-group">
            <span class="control-label">BRAND ELEMENT</span>
            <div class="svg-preview-container" id="svg-preview-container"></div>
        </div>

        <div class="control-group select-group">
            <span class="control-label">Motion</span>
            <select id="motion-type">
                <option value="swap">Swap</option>
                <option value="snap" selected>Snap</option>
                <option value="fade">Fade</option>
                <option value="robot">Robot</option>
                <option value="pair">Pair</option>
            </select>
        </div>

        <div class="control-group slider-group">
            <span class="control-label">Speed</span>
            <input type="range" id="speed-control" min="1" max="10" step="1" value="7" />
            <span id="speed-value" class="slider-value">7</span>
        </div>

        <div class="control-group slider-group">
            <span class="control-label">Size</span>
            <input type="range" id="size-control" min="0.5" max="2" step="0.1" value="0.5" />
            <span id="size-value" class="slider-value">0.5</span>
        </div>

        <div class="control-group select-group">
            <span class="control-label">Color</span>
            <select id="vector-color">
                <option value="#ffffff">White</option>
                <option value="#000000">Black</option>
            </select>
        </div>

        <label class="control-group toggle-group">
            <input type="checkbox" id="loop-toggle" checked />
            <span class="control-label">Loop</span>
        </label>

        <button id="export-screenshot">Screenshot</button>
        <button id="export-gif">Export GIF</button>

    </div>
    <div class="screenshot-menu" id="screenshot-menu">
        <button id="export-svg">Save as SVG</button>
        <button id="export-png">Save as PNG</button>
    </div>
    <div class="progress-container" id="progress-container">
        <div class="progress-bar" id="progress-bar"></div>
    </div>
    <span id="export-status"></span>
    <div id="svg-container"></div>
    <script src="https://cdn.jsdelivr.net/npm/gif.js.optimized/dist/gif.min.js"></script>
    <script>
        // Inlined GIF Worker Script for Offline Support
        const workerScriptText = `!function(t){function e(r){if(i[r])return i[r].exports;var s=i[r]={exports:{},id:r,loaded:!1};return t[r].call(s.exports,s,s.exports,e),s.loaded=!0,s.exports}var i={};return e.m=t,e.c=i,e.p="",e(0)}([function(t,e,i){var r,s;r=i(1),s=function(t){var e,i,s,o;return e=new r(t.width,t.height),0===t.index?e.writeHeader():e.firstFrame=!1,e.setTransparent(t.transparent),e.setRepeat(t.repeat),e.setDelay(t.delay),e.setQuality(t.quality),e.setDither(t.dither),e.setGlobalPalette(t.globalPalette),e.addFrame(t.data),t.last&&e.finish(),t.globalPalette===!0&&(t.globalPalette=e.getGlobalPalette()),s=e.stream(),t.data=s.pages,t.cursor=s.cursor,t.pageSize=s.constructor.pageSize,t.canTransfer?(o=function(){var e,r,s,o;for(s=t.data,o=[],e=0,r=s.length;e<r;e++)i=s[e],o.push(i.buffer);return o}(),self.postMessage(t,o)):self.postMessage(t)},self.onmessage=function(t){return s(t.data)}},function(t,e,i){function r(){this.page=-1,this.pages=[],this.newPage()}function s(t,e){this.width=~~t,this.height=~~e,this.transparent=null,this.transIndex=0,this.repeat=-1,this.delay=0,this.image=null,this.pixels=null,this.indexedPixels=null,this.colorDepth=null,this.colorTab=null,this.neuQuant=null,this.usedEntry=new Array,this.palSize=7,this.dispose=-1,this.firstFrame=!0,this.sample=10,this.dither=!1,this.globalPalette=!1,this.out=new r}var o=i(2),n=i(3);r.pageSize=4096,r.charMap={};for(var a=0;a<256;a++)r.charMap[a]=String.fromCharCode(a);r.prototype.newPage=function(){this.pages[++this.page]=new Uint8Array(r.pageSize),this.cursor=0},r.prototype.getData=function(){for(var t="",e=0;e<this.pages.length;e++)for(var i=0;i<r.pageSize;i++)t+=r.charMap[this.pages[e][i]];return t},r.prototype.writeByte=function(t){this.cursor>=r.pageSize&&this.newPage(),this.pages[this.page][this.cursor++]=t},r.prototype.writeUTFBytes=function(t){for(var e=t.length,i=0;i<e;i++)this.writeByte(t.charCodeAt(i))},r.prototype.writeBytes=function(t,e,i){for(var r=i||t.length,s=e||0;s<r;s++)this.writeByte(t[s])},s.prototype.setDelay=function(t){this.delay=Math.round(t/10)},s.prototype.setFrameRate=function(t){this.delay=Math.round(100/t)},s.prototype.setDispose=function(t){t>=0&&(this.dispose=t)},s.prototype.setRepeat=function(t){this.repeat=t},s.prototype.setTransparent=function(t){this.transparent=t},s.prototype.addFrame=function(t){this.image=t,this.colorTab=this.globalPalette&&this.globalPalette.slice?this.globalPalette:null,this.getImagePixels(),this.analyzePixels(),this.globalPalette===!0&&(this.globalPalette=this.colorTab),this.firstFrame&&(this.writeLSD(),this.writePalette(),this.repeat>=0&&this.writeNetscapeExt()),this.writeGraphicCtrlExt(),this.writeImageDesc(),this.firstFrame||this.globalPalette||this.writePalette(),this.writePixels(),this.firstFrame=!1},s.prototype.finish=function(){this.out.writeByte(59)},s.prototype.setQuality=function(t){t<1&&(t=1),this.sample=t},s.prototype.setDither=function(t){t===!0&&(t="FloydSteinberg"),this.dither=t},s.prototype.setGlobalPalette=function(t){this.globalPalette=t},s.prototype.getGlobalPalette=function(){return this.globalPalette&&this.globalPalette.slice&&this.globalPalette.slice(0)||this.globalPalette},s.prototype.writeHeader=function(){this.out.writeUTFBytes("GIF89a")},s.prototype.analyzePixels=function(){this.colorTab||(this.neuQuant=new o(this.pixels,this.sample),this.neuQuant.buildColormap(),this.colorTab=this.neuQuant.getColormap()),this.dither?this.ditherPixels(this.dither.replace("-serpentine",""),null!==this.dither.match(/-serpentine/)):this.indexPixels(),this.pixels=null,this.colorDepth=8,this.palSize=7,null!==this.transparent&&(this.transIndex=this.findClosest(this.transparent,!0))},s.prototype.indexPixels=function(){var t=this.pixels.length/3;this.indexedPixels=new Uint8Array(t);for(var e=0,i=0;i<t;i++){var r=this.findClosestRGB(255&this.pixels[e++],255&this.pixels[e++],255&this.pixels[e++]);this.usedEntry[r]=!0,this.indexedPixels[i]=r}},s.prototype.ditherPixels=function(t,e){var i={FalseFloydSteinberg:[[3/8,1,0],[3/8,0,1],[.25,1,1]],FloydSteinberg:[[7/16,1,0],[3/16,-1,1],[5/16,0,1],[1/16,1,1]],Stucki:[[8/42,1,0],[4/42,2,0],[2/42,-2,1],[4/42,-1,1],[8/42,0,1],[4/42,1,1],[2/42,2,1],[1/42,-2,2],[2/42,-1,2],[4/42,0,2],[2/42,1,2],[1/42,2,2]],Atkinson:[[1/8,1,0],[1/8,2,0],[1/8,-1,1],[1/8,0,1],[1/8,1,1],[1/8,0,2]]};if(!t||!i[t])throw"Unknown dithering kernel: "+t;var r=i[t],s=0,o=this.height,n=this.width,a=this.pixels,h=e?-1:1;this.indexedPixels=new Uint8Array(this.pixels.length/3);for(var l=0;l<o;l++){e&&(h*=-1);for(var u=1==h?0:n-1,p=1==h?n:0;u!==p;u+=h){s=l*n+u;var f=3*s,c=a[f],y=a[f+1],w=a[f+2];f=this.findClosestRGB(c,y,w),this.usedEntry[f]=!0,this.indexedPixels[s]=f,f*=3;for(var d=this.colorTab[f],g=this.colorTab[f+1],x=this.colorTab[f+2],b=c-d,v=y-g,P=w-x,m=1==h?0:r.length-1,B=1==h?r.length:0;m!==B;m+=h){var S=r[m][1],T=r[m][2];if(S+u>=0&&S+u<n&&T+l>=0&&T+l<o){var M=r[m][0];f=s+S+T*n,f*=3,a[f]=Math.max(0,Math.min(255,a[f]+b*M)),a[f+1]=Math.max(0,Math.min(255,a[f+1]+v*M)),a[f+2]=Math.max(0,Math.min(255,a[f+2]+P*M))}}}}},s.prototype.findClosest=function(t,e){return this.findClosestRGB((16711680&t)>>16,(65280&t)>>8,255&t,e)},s.prototype.findClosestRGB=function(t,e,i,r){if(null===this.colorTab)return-1;if(this.neuQuant&&!r)return this.neuQuant.lookupRGB(t,e,i);for(var s=0,o=16777216,n=this.colorTab.length,a=0,h=0;a<n;h++){var l=t-(255&this.colorTab[a++]),u=e-(255&this.colorTab[a++]),p=i-(255&this.colorTab[a++]),f=l*l+u*u+p*p;(!r||this.usedEntry[h])&&f<o&&(o=f,s=h)}return s},s.prototype.getImagePixels=function(){var t=this.width,e=this.height;this.pixels=new Uint8Array(t*e*3);for(var i=this.image,r=0,s=0,o=0;o<e;o++)for(var n=0;n<t;n++)this.pixels[s++]=i[r++],this.pixels[s++]=i[r++],this.pixels[s++]=i[r++],r++},s.prototype.writeGraphicCtrlExt=function(){this.out.writeByte(33),this.out.writeByte(249),this.out.writeByte(4);var t,e;null===this.transparent?(t=0,e=0):(t=1,e=2),this.dispose>=0&&(e=7&dispose),e<<=2,this.out.writeByte(0|e|0|t),this.writeShort(this.delay),this.out.writeByte(this.transIndex),this.out.writeByte(0)},s.prototype.writeImageDesc=function(){this.out.writeByte(44),this.writeShort(0),this.writeShort(0),this.writeShort(this.width),this.writeShort(this.height),this.firstFrame||this.globalPalette?this.out.writeByte(0):this.out.writeByte(128|this.palSize)},s.prototype.writeLSD=function(){this.writeShort(this.width),this.writeShort(this.height),this.out.writeByte(240|this.palSize),this.out.writeByte(0),this.out.writeByte(0)},s.prototype.writeNetscapeExt=function(){this.out.writeByte(33),this.out.writeByte(255),this.out.writeByte(11),this.out.writeUTFBytes("NETSCAPE2.0"),this.out.writeByte(3),this.out.writeByte(1),this.writeShort(this.repeat),this.out.writeByte(0)},s.prototype.writePalette=function(){this.out.writeBytes(this.colorTab);for(var t=768-this.colorTab.length,e=0;e<t;e++)this.out.writeByte(0)},s.prototype.writeShort=function(t){this.out.writeByte(255&t),this.out.writeByte(t>>8&255)},s.prototype.writePixels=function(){var t=new n(this.width,this.height,this.indexedPixels,this.colorDepth);t.encode(this.out)},s.prototype.stream=function(){return this.out},t.exports=s},function(t,e){function i(t,e){function i(){z=[],E=new Int32Array(256),R=new Int32Array(s),U=new Int32Array(s),Q=new Int32Array(s>>3);var t,e;for(t=0;t<s;t++)e=(t<<n+8)/s,z[t]=new Float64Array([e,e,e,0]),U[t]=h/s,R[t]=0}function c(){for(var t=0;t<s;t++)z[t][0]>>=n,z[t][1]>>=n,z[t][2]>>=n,z[t][3]=t}function w(t,e,i,r,s){z[e][0]-=t*(z[e][0]-i)/b,z[e][1]-=t*(z[e][1]-r)/b,z[e][2]-=t*(z[e][2]-s)/b}function x(t,e,i,r,o){for(var n,a,h=Math.abs(e-t),l=Math.min(e+t,s),u=e+1,p=e-1,f=1;u<l||p>h;)a=Q[f++],u<l&&(n=z[u++],n[0]-=a*(n[0]-i)/B,n[1]-=a*(n[1]-r)/B,n[2]-=a*(n[2]-o)/B),p>h&&(n=z[p--],n[0]-=a*(n[0]-i)/B,n[1]-=a*(n[1]-r)/B,n[2]-=a*(n[2]-o)/B)}function v(t,e,i){t=0|t,e=0|e,i=0|i;var r,o,h,c,y,w=~(1<<31),d=w,g=-1,x=g;for(r=0;r<s;r++)o=z[r],h=Math.abs((0|o[0])-t)+Math.abs((0|o[1])-e)+Math.abs((0|o[2])-i)|0,h<w&&(w=h,g=r),c=h-((0|R[r])>>a-n),c<d&&(d=c,x=r),y=U[r]>>u,U[r]-=y,R[r]+=y<<l;return U[g]+=p,R[g]-=f,x}function m(){var t,e,i,r,n,a,h=0,l=0;for(t=0;t<s;t++){for(i=z[t],n=t,a=i[1],e=t+1;e<s;e++)r=z[e],r[1]<a&&(n=e,a=r[1]);if(r=z[n],t!=n&&(e=r[0],r[0]=i[0],i[0]=e,e=r[1],r[1]=i[1],i[1]=e,e=r[2],r[2]=i[2],i[2]=e,e=r[3],r[3]=i[3],i[3]=e),a!=h){for(E[h]=l+t>>1,e=h+1;e<a;e++)E[e]=t;h=a,l=t}}for(E[h]=l+o>>1,e=h+1;e<256;e++)E[e]=o}function C(t,e,i){t=0|t,e=0|e,i=0|i;for(var r,o,n,a=1e3,h=-1,l=0|E[e],u=l-1;l<s||u>=0;)l<s&&(o=z[l],n=(0|o[1])-e,n>=a?l=s:(l++,n<0&&(n=-n),r=(0|o[0])-t,r<0&&(r=-r),n+=r,n<a&&(r=(0|o[2])-i,r<0&&(r=-r),n+=r,n<a&&(a=n,h=0|o[3])))),u>=0&&(o=z[u],n=e-(0|o[1]),n>=a?u=-1:(u--,n<0&&(n=-n),r=(0|o[0])-t,r<0&&(r=-r),n+=r,n<a&&(r=(0|o[2])-i,r<0&&(r=-r),n+=r,n<a&&(a=n,h=0|o[3]))));return h}function I(){var i,s=t.length,o=30+(e-1)/3,a=s/(3*e),h=~~(a/r),l=b,u=d,p=u>>y;for(p<=1&&(p=0),i=0;i<p;i++)Q[i]=l*((p*p-i*i)*P/(p*p));var f;s<A?(e=1,f=3):f=s%S!==0?3*S:s%T!==0?3*T:s%M!==0?3*M:3*F;var c,m,B,C,I=0;for(i=0;i<a;)if(c=(255&t[I])<<n,m=(255&t[I+1])<<n,B=(255&t[I+2])<<n,C=v(c,m,B),w(l,C,c,m,B),0!==p&&x(p,C,c,m,B),I+=f,I>=s&&(I-=s),i++,0===h&&(h=1),i%h===0)for(l-=l/o,u-=u/g,p=u>>y,p<=1&&(p=0),C=0;C<p;C++)Q[C]=l*((p*p-C*C)*P/(p*p))}function D(){i(),I(),c(),m()}function G(){for(var t=[],e=[],i=0;i<s;i++)e[z[i][3]]=i;for(var r=0,o=0;o<s;o++){var n=e[o];t[r++]=z[n][0],t[r++]=z[n][1],t[r++]=z[n][2]}return t}var z,E,R,U,Q;this.buildColormap=D,this.getColormap=G,this.lookupRGB=C}var r=100,s=256,o=s-1,n=4,a=16,h=1<<a,l=10,u=10,p=h>>u,f=h<<l-u,c=s>>3,y=6,w=1<<y,d=c*w,g=30,x=10,b=1<<x,v=8,P=1<<v,m=x+v,B=1<<m,S=499,T=491,M=487,F=503,A=3*F;t.exports=i},function(t,e){function i(t,e,i,a){function h(t,e){S[x++]=t,x>=254&&c(e)}function l(t){u(o),A=P+2,C=!0,d(P,t)}function u(t){for(var e=0;e<t;++e)T[e]=-1}function p(t,e){var i,n,a,h,p,f,c;for(v=t,C=!1,n_bits=v,b=y(n_bits),P=1<<t-1,m=P+1,A=P+2,x=0,h=w(),c=0,i=o;i<65536;i*=2)++c;c=8-c,f=o,u(f),d(P,e);t:for(;(n=w())!=r;)if(i=(n<<s)+h,a=n<<c^h,T[a]!==i){if(T[a]>=0){p=f-a,0===a&&(p=1);do if((a-=p)<0&&(a+=f),T[a]===i){h=M[a];continue t}while(T[a]>=0)}d(h,e),h=n,A<1<<s?(M[a]=A++,T[a]=i):l(e)}else h=M[a];d(h,e),d(m,e)}function f(i){i.writeByte(B),remaining=t*e,curPixel=0,p(B+1,i),i.writeByte(0)}function c(t){x>0&&(t.writeByte(x),t.writeBytes(S,0,x),x=0)}function y(t){return(1<<t)-1}function w(){if(0===remaining)return r;--remaining;var t=i[curPixel++];return 255&t}function d(t,e){for(g&=n[F],F>0?g|=t<<F:g=t,F+=n_bits;F>=8;)h(255&g,e),g>>=8,F-=8;if((A>b||C)&&(C?(b=y(n_bits=v),C=!1):(++n_bits,b=n_bits==s?1<<s:y(n_bits))),t==m){for(;F>0;)h(255&g,e),g>>=8,F-=8;c(e)}}var g,x,b,v,P,m,B=Math.max(2,a),S=new Uint8Array(256),T=new Int32Array(o),M=new Int32Array(o),F=0,A=0,C=!1;this.encode=f}var r=-1,s=12,o=5003,n=[0,1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535];t.exports=i}]);`;

        let workerBlobUrl = null;
        let isExporting = false;
        let currentSVG = null;
        let paths = [];
        let animationHandle = null;
        let animationTime = 0;
        let savedPathStates = [];
        let swapPairs = [];
        let robotSequence = [];
        let pairSequence = [];
        let gridColumns = 0;
        let gridRows = 0;
        let cachedViewBox = null;
        let cachedSvgWidth = 584;

        const container = document.getElementById('svg-container');
        const exportButton = document.getElementById('export-gif');
        const statusLabel = document.getElementById('export-status');
        const speedControl = document.getElementById('speed-control');
        const speedValue = document.getElementById('speed-value');
        const sizeControl = document.getElementById('size-control');
        const sizeValue = document.getElementById('size-value');
        const loopToggle = document.getElementById('loop-toggle');
        const vectorColorSelect = document.getElementById('vector-color');
        const motionTypeSelect = document.getElementById('motion-type');
        const svgPreviewContainer = document.getElementById('svg-preview-container');
        const screenshotButton = document.getElementById('export-screenshot');
        const screenshotMenu = document.getElementById('screenshot-menu');
        const exportSvgButton = document.getElementById('export-svg');
        const exportPngButton = document.getElementById('export-png');
        let currentSelectedSvg = 'Opt 2/10.svg';
        const progressContainer = document.getElementById('progress-container');
        const progressBar = document.getElementById('progress-bar');
        const captureCanvas = document.createElement('canvas');
        const captureCtx = captureCanvas.getContext('2d', { willReadFrequently: true });
        const serializer = new XMLSerializer();

        let currentSpeed = parseInt(speedControl.value) * 0.01;
        let currentSize = parseFloat(sizeControl.value);
        let currentMotionType = motionTypeSelect.value;

        speedValue.textContent = speedControl.value;
        sizeValue.textContent = currentSize.toFixed(1);

        function updatePageBackgroundForVectorColor(color) {
            const isBlackLogo = color === '#000000';
            document.body.style.backgroundColor = isBlackLogo ? '#f5f5f5' : '#111';
            const studioMark = document.querySelector('.studio-mark');
            const toolTitle = document.querySelector('.tool-title');
            if (studioMark) {
                studioMark.className = 'studio-mark ' + (isBlackLogo ? 'light-bg' : 'dark-bg');
            }
            if (toolTitle) {
                toolTitle.className = 'tool-title ' + (isBlackLogo ? 'light-bg' : 'dark-bg');
            }
            // Update preview SVG filters
            svgPreviewContainer.querySelectorAll('.svg-preview-item object').forEach(obj => {
                obj.style.filter = isBlackLogo ? 'none' : 'invert(1)';
            });
        }

        function applyVectorColor(color) {
            if (!currentSVG) return;
            paths.forEach(path => {
                path.setAttribute('fill', color);
                path.setAttribute('stroke', color);
            });
        }

        async function loadSVG(filePath) {
            try {
                const response = await fetch(filePath);
                const svgContent = await response.text();
                container.innerHTML = svgContent;
                currentSVG = container.querySelector('svg');
                
                if (!currentSVG) {
                    throw new Error('No SVG found in file');
                }

                // Get all path elements
                paths = Array.from(currentSVG.querySelectorAll('path'));
                
                // Store original states with grid positions - pre-calculate transform base values
                savedPathStates = paths.map((path, index) => {
                    const bbox = path.getBBox();
                    const centerX = bbox.x + bbox.width / 2;
                    const centerY = bbox.y + bbox.height / 2;
                    const baseX = centerX - bbox.x - bbox.width / 2;
                    const baseY = centerY - bbox.y - bbox.height / 2;
                    return {
                        element: path,
                        bbox: bbox,
                        originalFill: path.getAttribute('fill') || 'black',
                        originalOpacity: path.getAttribute('opacity') || '1',
                        centerX: centerX,
                        centerY: centerY,
                        baseX: baseX,
                        baseY: baseY,
                        index: index
                    };
                });

                // Create swap pairs and robot sequence for geometric motion after a short delay to ensure bbox is ready
                setTimeout(() => {
                    initializeSwapPairs();
                }, 100);

                // Wrap all SVG content in a group for scaling
                const scaleGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                while (currentSVG.firstChild) {
                    scaleGroup.appendChild(currentSVG.firstChild);
                }
                currentSVG.appendChild(scaleGroup);
                currentSVG.scaleGroup = scaleGroup;

                // Add style for animations - sharp transitions for geometric motion
                // Optimized for performance with hardware acceleration
                const style = document.createElementNS('http://www.w3.org/2000/svg', 'style');
                style.textContent = `path { transform-box: fill-box; transform-origin: center; will-change: transform, opacity; transition: none; transform: translateZ(0); backface-visibility: hidden; }`;
                currentSVG.appendChild(style);

                // Cache viewBox for performance
                cachedViewBox = currentSVG.viewBox?.baseVal;
                cachedSvgWidth = cachedViewBox ? cachedViewBox.width : 584;
                
                // Apply initial settings
                applyVectorColor(vectorColorSelect.value);
                updateLogoScale();
                updatePageBackgroundForVectorColor(vectorColorSelect.value);
                
            } catch (error) {
                console.error('Error loading SVG:', error);
                statusLabel.textContent = 'Error loading SVG';
            }
        }

        function updateLogoScale() {
            if (!currentSVG || !currentSVG.scaleGroup) return;
            const clampedSize = Math.max(0.5, Math.min(2, currentSize));
            // Use cached viewBox for better performance
            if (!cachedViewBox) {
                cachedViewBox = currentSVG.viewBox?.baseVal;
            }
            if (!cachedViewBox) return;
            
            const cx = cachedViewBox.x + cachedViewBox.width / 2;
            const cy = cachedViewBox.y + cachedViewBox.height / 2;
            
            currentSVG.scaleGroup.setAttribute(
                'transform',
                `translate(${cx} ${cy}) scale(${clampedSize}) translate(${-cx} ${-cy})`
            );
        }

        function initializeSwapPairs() {
            if (paths.length === 0 || savedPathStates.length === 0) return;
            
            // Analyze grid structure based on actual positions
            const positions = savedPathStates.map(state => ({
                x: Math.round(state.centerX / 10) * 10, // Round to nearest 10 for grid detection
                y: Math.round(state.centerY / 10) * 10
            }));
            
            // Find unique Y and X positions for grid
            const yPositions = [...new Set(positions.map(p => p.y))].sort((a, b) => a - b);
            const xPositions = [...new Set(positions.map(p => p.x))].sort((a, b) => a - b);
            
            gridRows = yPositions.length || 1;
            gridColumns = xPositions.length || paths.length;
            
            // Create swap pairs - each piece swaps with another in grid
            swapPairs = savedPathStates.map((state, index) => {
                const stateX = Math.round(state.centerX / 10) * 10;
                const stateY = Math.round(state.centerY / 10) * 10;
                
                // Calculate grid position
                const gridX = xPositions.indexOf(stateX);
                const gridY = yPositions.indexOf(stateY);
                
                // Find swap partner - opposite corner or adjacent
                let swapIndex = index;
                if (paths.length > 1) {
                    // Try mirror/diagonal swap
                    const mirrorX = gridColumns - 1 - gridX;
                    const mirrorY = gridRows - 1 - gridY;
                    
                    // Find index at mirror position
                    swapIndex = savedPathStates.findIndex((s, i) => {
                        const sx = Math.round(s.centerX / 10) * 10;
                        const sy = Math.round(s.centerY / 10) * 10;
                        const sxGrid = xPositions.indexOf(sx);
                        const syGrid = yPositions.indexOf(sy);
                        return sxGrid === mirrorX && syGrid === mirrorY && i !== index;
                    });
                    
                    // Fallback: swap with opposite end
                    if (swapIndex === -1) {
                        swapIndex = (index + Math.floor(paths.length / 2)) % paths.length;
                    }
                }
                
                return {
                    from: index,
                    to: swapIndex,
                    fromX: state.centerX,
                    fromY: state.centerY,
                    toX: savedPathStates[swapIndex] ? savedPathStates[swapIndex].centerX : state.centerX,
                    toY: savedPathStates[swapIndex] ? savedPathStates[swapIndex].centerY : state.centerY
                };
            });

            // Initialize robot sequence - cascading chain where each moves to next position
            robotSequence = savedPathStates.map((state, index) => {
                // Each piece moves to the next piece's position (circular)
                const nextIndex = (index + 1) % savedPathStates.length;
                const nextState = savedPathStates[nextIndex];
                return {
                    fromIndex: index,
                    toIndex: nextIndex,
                    fromX: state.centerX,
                    fromY: state.centerY,
                    toX: nextState ? nextState.centerX : state.centerX,
                    toY: nextState ? nextState.centerY : state.centerY
                };
            });

            // Initialize pair sequence - pairs move 2 by 2, swapping positions
            pairSequence = [];
            for (let i = 0; i < savedPathStates.length; i += 2) {
                if (i + 1 < savedPathStates.length) {
                    // Pair: i and i+1 swap positions
                    const state1 = savedPathStates[i];
                    const state2 = savedPathStates[i + 1];
                    
                    pairSequence.push({
                        index: i,
                        partnerIndex: i + 1,
                        fromX: state1.centerX,
                        fromY: state1.centerY,
                        toX: state2.centerX,
                        toY: state2.centerY,
                        isFirst: true
                    });
                    
                    pairSequence.push({
                        index: i + 1,
                        partnerIndex: i,
                        fromX: state2.centerX,
                        fromY: state2.centerY,
                        toX: state1.centerX,
                        toY: state1.centerY,
                        isFirst: false
                    });
                } else {
                    // Odd one out - stays in place
                    const state = savedPathStates[i];
                    pairSequence.push({
                        index: i,
                        partnerIndex: i,
                        fromX: state.centerX,
                        fromY: state.centerY,
                        toX: state.centerX,
                        toY: state.centerY,
                        isFirst: false
                    });
                }
            }
        }

        function getMotionValue(pathIndex, totalPaths, time, motionType, speed) {
            const staggerOffset = pathIndex / totalPaths;
            const progress = (staggerOffset + time * speed) % 1;
            
            // Sharp step function - no smooth transitions (pre-calculated for performance)
            const step = progress < 0.5 ? 0 : 1;
            const sharpProgress = step;

            switch (motionType) {
                case 'swap':
                    // Linear swap - pieces move in straight lines to exchange positions
                    if (swapPairs.length === 0) {
                        initializeSwapPairs();
                        return { x: 0, y: 0, swap: false };
                    }
                    const pair = swapPairs[pathIndex];
                    if (!pair) return { x: 0, y: 0, swap: false };
                    
                    // Linear movement but with sharp timing steps
                    const swapProgress = progress < 0.5 ? progress * 2 : 1; // First half: move, second half: stay
                    const swapDeltaX = pair.toX - pair.fromX;
                    const swapDeltaY = pair.toY - pair.fromY;
                    
                    return {
                        x: pair.fromX + swapDeltaX * swapProgress,
                        y: pair.fromY + swapDeltaY * swapProgress,
                        swap: true
                    };

                case 'snap':
                    // Snap to adjacent grid positions - instant movement
                    const snapState = savedPathStates[pathIndex];
                    if (!snapState) return { x: 0, y: 0, swap: false };
                    
                    const snapStep = Math.floor(progress * Math.min(4, totalPaths));
                    const targetIndex = (pathIndex + snapStep) % totalPaths;
                    const target = savedPathStates[targetIndex];
                    
                    if (!target) return { x: 0, y: 0, swap: false };
                    
                    return {
                        x: target.centerX - snapState.centerX,
                        y: target.centerY - snapState.centerY,
                        swap: false
                    };

                case 'robot':
                    // Cascading robot movement - perfect chain where each piece moves to next position
                    // A→B, B→C, C→D... maintaining grid structure
                    if (robotSequence.length === 0) {
                        initializeSwapPairs();
                        return { x: 0, y: 0, swap: false };
                    }
                    
                    const robotSeq = robotSequence[pathIndex];
                    if (!robotSeq) return { x: 0, y: 0, swap: false };
                    
                    // Much faster cascading - reduced delay for quicker action
                    const cascadeDelay = (pathIndex / totalPaths) * 0.15; // Much faster - 0.15 instead of 0.3
                    const cascadeDuration = 0.25; // Faster movement - 0.25 instead of 0.4
                    const cascadeStart = cascadeDelay;
                    const cascadeEnd = cascadeStart + cascadeDuration;
                    
                    let cascadeProgress = 0;
                    if (progress >= cascadeStart && progress <= cascadeEnd) {
                        cascadeProgress = (progress - cascadeStart) / cascadeDuration;
                    } else if (progress > cascadeEnd) {
                        cascadeProgress = 1;
                    }
                    
                    // Sharp mechanical movement - fewer steps for faster response
                    const robotStep = Math.floor(cascadeProgress * 6) / 6; // 6 steps instead of 8
                    const robotProgress = Math.max(0, Math.min(1, robotStep));
                    
                    // Move from original position to next piece's position
                    const robotDeltaX = robotSeq.toX - robotSeq.fromX;
                    const robotDeltaY = robotSeq.toY - robotSeq.fromY;
                    
                    return {
                        x: robotSeq.fromX + robotDeltaX * robotProgress,
                        y: robotSeq.fromY + robotDeltaY * robotProgress,
                        swap: true
                    };

                case 'fade':
                    // Simple fade in/out
                    const fadePhase = progress;
                    const fadeOpacity = fadePhase < 0.5 ? fadePhase * 2 : 2 - fadePhase * 2;
                    return { opacity: Math.max(0, Math.min(1, fadeOpacity)), swap: false };

                case 'pair':
                    // Pair motion - shapes move 2 by 2, swapping positions without overlapping
                    if (pairSequence.length === 0) {
                        initializeSwapPairs();
                        return { x: 0, y: 0, swap: false };
                    }
                    
                    const pairInfo = pairSequence.find(p => p.index === pathIndex);
                    if (!pairInfo) return { x: 0, y: 0, swap: false };
                    
                    // Calculate which pair group this belongs to
                    const pairGroup = Math.floor(pathIndex / 2);
                    const totalPairs = Math.ceil(totalPaths / 2);
                    
                    // Stagger pairs so they move sequentially without overlapping
                    const pairDelay = (pairGroup / totalPairs) * 0.2;
                    const pairDuration = 0.3;
                    const pairStart = pairDelay;
                    const pairEnd = pairStart + pairDuration;
                    
                    let pairProgress = 0;
                    if (progress >= pairStart && progress <= pairEnd) {
                        pairProgress = (progress - pairStart) / pairDuration;
                    } else if (progress > pairEnd) {
                        pairProgress = 1;
                    }
                    
                    // Sharp movement - discrete steps for mechanical feel
                    const pairStep = Math.floor(pairProgress * 8) / 8;
                    const pairMoveProgress = Math.max(0, Math.min(1, pairStep));
                    
                    // Move to partner's position
                    const pairDeltaX = pairInfo.toX - pairInfo.fromX;
                    const pairDeltaY = pairInfo.toY - pairInfo.fromY;
                    
                    return {
                        x: pairInfo.fromX + pairDeltaX * pairMoveProgress,
                        y: pairInfo.fromY + pairDeltaY * pairMoveProgress,
                        swap: true
                    };

                default:
                    return { x: 0, y: 0, swap: false };
            }
        }

        let cachedMotionType = 'swap';
        
        function renderAnimation() {
            if (!currentSVG || paths.length === 0) return;

            const totalPaths = paths.length;
            cachedMotionType = motionTypeSelect.value; // Cache to avoid repeated DOM reads

            // Optimize: batch DOM updates by motion type, use for loop instead of forEach
            for (let i = 0; i < paths.length; i++) {
                const path = paths[i];
                const state = savedPathStates[i];
                const value = getMotionValue(i, totalPaths, animationTime, cachedMotionType, currentSpeed);
                
                // Use cached baseX/baseY instead of recalculating
                const baseX = state.baseX;
                const baseY = state.baseY;
                const centerX = state.centerX;
                const centerY = state.centerY;

                switch (cachedMotionType) {
                    case 'swap':
                        if (value.swap) {
                            const offsetX = value.x - centerX;
                            const offsetY = value.y - centerY;
                            path.style.transform = `translate(${baseX + offsetX}px,${baseY + offsetY}px)`;
                        } else {
                            path.style.transform = `translate(${baseX}px,${baseY}px)`;
                        }
                        path.style.opacity = '1';
                        break;

                    case 'snap':
                        path.style.transform = `translate(${baseX + value.x}px,${baseY + value.y}px)`;
                        path.style.opacity = '1';
                        break;

                    case 'robot':
                    case 'pair':
                        // Cascading/pair movement - pieces flow through positions
                        if (value.swap) {
                            const offsetX = value.x - centerX;
                            const offsetY = value.y - centerY;
                            path.style.transform = `translate(${baseX + offsetX}px,${baseY + offsetY}px)`;
                        } else {
                            path.style.transform = `translate(${baseX}px,${baseY}px)`;
                        }
                        path.style.opacity = '1';
                        break;

                    case 'fade':
                        path.style.transform = `translate(${baseX}px,${baseY}px)`;
                        path.style.opacity = value.opacity !== undefined ? value.opacity : '1';
                        break;
                }
            }
        }

        let lastFrameTime = performance.now();
        
        function animate(currentTime) {
            if (loopToggle.checked) {
                // Use actual frame time for smooth animation
                const deltaTime = (currentTime - lastFrameTime) / 1000;
                animationTime += Math.min(deltaTime, 0.033); // Cap at ~30fps minimum
                lastFrameTime = currentTime;
            }
            renderAnimation();
            animationHandle = requestAnimationFrame(animate);
        }

        function startAnimation() {
            if (loopToggle.checked && !animationHandle) {
                lastFrameTime = performance.now();
                animationHandle = requestAnimationFrame(animate);
            }
        }

        function stopAnimation() {
            if (animationHandle) {
                cancelAnimationFrame(animationHandle);
                animationHandle = null;
            }
        }

        // Create SVG preview selector
        const svgFiles = [
            'Opt 2/10.svg', 'Opt 2/01.svg', 'Opt 2/02.svg', 'Opt 2/03.svg', 'Opt 2/04.svg',
            'Opt 2/05.svg', 'Opt 2/06.svg', 'Opt 2/07.svg', 'Opt 2/08.svg', 'Opt 2/09.svg'
        ];

        function createSvgPreview(filePath, index) {
            const previewItem = document.createElement('div');
            previewItem.className = 'svg-preview-item';
            if (filePath === 'Opt 2/10.svg') previewItem.classList.add('active');
            
            // Use object element for better SVG rendering
            const svgObject = document.createElement('object');
            svgObject.data = filePath;
            svgObject.type = 'image/svg+xml';
            svgObject.width = '36';
            svgObject.height = '36';
            svgObject.style.pointerEvents = 'none';
            
            // Set initial filter based on current background
            const isBlackLogo = vectorColorSelect.value === '#000000';
            svgObject.style.filter = isBlackLogo ? 'none' : 'invert(1)';
            svgObject.style.opacity = '0.8';
            
            svgObject.onerror = () => {
                previewItem.innerHTML = `<span style="font-size: 0.6rem; opacity: 0.5; color: currentColor;">${index + 1}</span>`;
            };
            
            previewItem.appendChild(svgObject);
            previewItem.addEventListener('click', () => {
                // Update active state
                svgPreviewContainer.querySelectorAll('.svg-preview-item').forEach(item => {
                    item.classList.remove('active');
                });
                previewItem.classList.add('active');
                
                // Load SVG
                currentSelectedSvg = filePath;
                stopAnimation();
                swapPairs = [];
                robotSequence = [];
                pairSequence = [];
                loadSVG(filePath).then(() => {
                    setTimeout(() => {
                        initializeSwapPairs();
                        startAnimation();
                    }, 150);
                });
            });
            
            return previewItem;
        }

        // Initialize preview selector
        svgFiles.forEach((file, index) => {
            svgPreviewContainer.appendChild(createSvgPreview(file, index));
        });

        speedControl.addEventListener('input', () => {
            currentSpeed = parseInt(speedControl.value) * 0.01;
            speedValue.textContent = speedControl.value;
        });

        sizeControl.addEventListener('input', () => {
            currentSize = parseFloat(sizeControl.value);
            sizeValue.textContent = currentSize.toFixed(1);
            updateLogoScale();
        });

        vectorColorSelect.addEventListener('change', () => {
            applyVectorColor(vectorColorSelect.value);
            updatePageBackgroundForVectorColor(vectorColorSelect.value);
        });

        loopToggle.addEventListener('change', () => {
            if (loopToggle.checked) {
                startAnimation();
            } else {
                stopAnimation();
            }
        });

        motionTypeSelect.addEventListener('change', () => {
            currentMotionType = motionTypeSelect.value;
            cachedMotionType = currentMotionType; // Update cache immediately
        });

        // Export Functions
        async function wait(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        function serializeSvg() {
            if (!currentSVG) return '';
            const clone = currentSVG.cloneNode(true);
            clone.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
            const viewBox = currentSVG.viewBox?.baseVal;
            if (viewBox) {
                const clampedSize = Math.max(0.5, Math.min(2, currentSize));
                const safetyFactor = 1.05;
                const scaledWidth = viewBox.width * clampedSize * safetyFactor;
                const scaledHeight = viewBox.height * clampedSize * safetyFactor;
                const centerX = viewBox.x + viewBox.width / 2;
                const centerY = viewBox.y + viewBox.height / 2;
                
                clone.setAttribute('width', scaledWidth);
                clone.setAttribute('height', scaledHeight);
                clone.setAttribute('viewBox', `${centerX - scaledWidth / 2} ${centerY - scaledHeight / 2} ${scaledWidth} ${scaledHeight}`);
            }
            return serializer.serializeToString(clone);
        }

        function drawSvgToCanvas() {
            return new Promise((resolve, reject) => {
                const svgString = serializeSvg();
                if (!svgString) {
                    reject(new Error('No SVG to render'));
                    return;
                }
                const encoded = window.btoa(unescape(encodeURIComponent(svgString)));
                const image = new Image();
                image.onload = () => {
                    const isBlackLogo = vectorColorSelect.value === '#000000';
                    const keyColor = isBlackLogo ? '#111111' : '#000000';
                    captureCtx.fillStyle = keyColor;
                    captureCtx.fillRect(0, 0, captureCanvas.width, captureCanvas.height);
                    captureCtx.drawImage(image, 0, 0, captureCanvas.width, captureCanvas.height);
                    resolve();
                };
                image.onerror = reject;
                image.src = `data:image/svg+xml;base64,${encoded}`;
            });
        }

        function updateStatus(message, progress = 0) {
            statusLabel.textContent = message;
            if (progress > 0) {
                progressContainer.style.display = 'block';
                progressBar.style.width = `${progress * 100}%`;
            } else {
                progressContainer.style.display = 'none';
                progressBar.style.width = '0%';
            }
        }

        async function ensureWorkerBlobUrl() {
            if (workerBlobUrl) {
                return workerBlobUrl;
            }
            const blob = new Blob([workerScriptText], { type: 'application/javascript' });
            workerBlobUrl = URL.createObjectURL(blob);
            return workerBlobUrl;
        }

        function getSelectedFps() {
            return 60;
        }

        async function exportGif() {
            if (isExporting || !currentSVG) {
                return;
            }
            isExporting = true;
            exportButton.disabled = true;
            updateStatus('Preparing export...');

            const viewBox = currentSVG.viewBox?.baseVal;
            if (!viewBox) {
                updateStatus('Error: No viewBox found');
                exportButton.disabled = false;
                isExporting = false;
                return;
            }

            const clampedSize = Math.max(0.5, Math.min(2, currentSize));
            const safetyFactor = 1.05;
            const baseExportWidth = Math.round(viewBox.width);
            const baseExportHeight = Math.round(viewBox.height);
            const exportWidth = Math.round(baseExportWidth * clampedSize * safetyFactor);
            const exportHeight = Math.round(baseExportHeight * clampedSize * safetyFactor);
            
            captureCanvas.width = exportWidth;
            captureCanvas.height = exportHeight;

            const selectedFps = getSelectedFps();
            const frameDelayMs = Math.round(1000 / selectedFps);
            const safeSpeed = Math.max(currentSpeed, 0.001);
            
            // Calculate loop duration to match preview speed exactly
            // Preview increments animationTime by 0.016 per frame (assumes ~60fps)
            // Motion progress = (staggerOffset + time * speed) % 1
            // For a full cycle: time * speed must reach 1 (then wraps)
            // Cycle duration in preview = 1 / speed (in the time units used)
            // At ~60fps preview: 1 cycle = (1 / speed) / 0.016 frames
            // To match speed visually, we need the same duration in seconds
            // At selectedFps: totalFrames = (1 / speed) * selectedFps
            
            const cycleDurationSeconds = 1 / safeSpeed;
            const totalFrames = Math.max(selectedFps, Math.ceil(cycleDurationSeconds * selectedFps));
            
            // Preview frame increment (what we use in animate function)
            const previewFrameIncrement = 0.016;
            
            const workerUrl = await ensureWorkerBlobUrl();
            const isBlackLogo = vectorColorSelect.value === '#000000';
            const transparentColor = isBlackLogo ? 0x111111 : 0x000000;

            const gif = new GIF({
                workerScript: workerUrl,
                workers: 2,
                quality: 10,
                width: captureCanvas.width,
                height: captureCanvas.height,
                transparent: transparentColor
            });

            const savedTime = animationTime;
            stopAnimation();

            try {
                // Calculate the time increment per export frame to match preview speed
                // Preview: animationTime += 0.016 per frame at ~60fps
                // Export at selectedFps: each frame represents 1/selectedFps seconds
                // To match: increment should be proportional
                // If preview is ~60fps, export frame increment = 0.016 * (60 / selectedFps)
                const exportFrameIncrement = previewFrameIncrement * (60 / selectedFps);
                
                for (let i = 0; i < totalFrames; i++) {
                    // Set animationTime to match what preview would show at this frame
                    animationTime = i * exportFrameIncrement;
                    renderAnimation();
                    await drawSvgToCanvas();
                    gif.addFrame(captureCtx, { copy: true, delay: frameDelayMs });
                    const progress = (i + 1) / totalFrames;
                    updateStatus(`Capturing frame ${i + 1} / ${totalFrames}`, progress * 0.5);
                    await wait(10);
                }

                gif.on('progress', p => {
                    updateStatus(`Rendering ${(p * 100).toFixed(0)}%`, 0.5 + (p * 0.5));
                });

                gif.on('finished', blob => {
                    animationTime = savedTime;
                    startAnimation();
                    const url = URL.createObjectURL(blob);
                    const anchor = document.createElement('a');
                    anchor.href = url;
                    anchor.download = `motion-${currentSelectedSvg.split('/').pop().replace('.svg', '')}.gif`;
                    document.body.appendChild(anchor);
                    anchor.click();
                    anchor.remove();
                    URL.revokeObjectURL(url);
                    updateStatus('GIF ready', 0);
                    exportButton.disabled = false;
                    isExporting = false;
                    setTimeout(() => { progressContainer.style.display = 'none'; }, 2000);
                });

                gif.on('abort', () => {
                    throw new Error('GIF rendering aborted.');
                });

                gif.render();
            } catch (error) {
                console.error(error);
                updateStatus('Export failed. Check console for details.');
                exportButton.disabled = false;
                isExporting = false;
                animationTime = savedTime;
                startAnimation();
            }
        }

        exportButton.addEventListener('click', exportGif);

        // Screenshot functionality
        screenshotButton.addEventListener('click', (e) => {
            e.stopPropagation();
            screenshotMenu.classList.toggle('show');
        });

        // Close menu when clicking outside
        document.addEventListener('click', (e) => {
            if (!screenshotMenu.contains(e.target) && e.target !== screenshotButton) {
                screenshotMenu.classList.remove('show');
            }
        });

        async function exportScreenshot(format) {
            if (!currentSVG) return;
            
            screenshotMenu.classList.remove('show');
            updateStatus('Preparing screenshot...');

            const viewBox = currentSVG.viewBox?.baseVal;
            if (!viewBox) {
                updateStatus('Error: No viewBox found');
                return;
            }

            const clampedSize = Math.max(0.5, Math.min(2, currentSize));
            const safetyFactor = 1.05;
            const baseExportWidth = Math.round(viewBox.width);
            const baseExportHeight = Math.round(viewBox.height);
            const exportWidth = Math.round(baseExportWidth * clampedSize * safetyFactor);
            const exportHeight = Math.round(baseExportHeight * clampedSize * safetyFactor);

            if (format === 'svg') {
                const svgString = serializeSvg();
                const blob = new Blob([svgString], { type: 'image/svg+xml' });
                const url = URL.createObjectURL(blob);
                const anchor = document.createElement('a');
                anchor.href = url;
                anchor.download = `screenshot-${currentSelectedSvg.split('/').pop().replace('.svg', '')}.svg`;
                document.body.appendChild(anchor);
                anchor.click();
                anchor.remove();
                URL.revokeObjectURL(url);
                updateStatus('SVG saved');
            } else if (format === 'png') {
                captureCanvas.width = exportWidth;
                captureCanvas.height = exportHeight;
                
                await drawSvgToCanvas();
                
                captureCanvas.toBlob((blob) => {
                    const url = URL.createObjectURL(blob);
                    const anchor = document.createElement('a');
                    anchor.href = url;
                    anchor.download = `screenshot-${currentSelectedSvg.split('/').pop().replace('.svg', '')}.png`;
                    document.body.appendChild(anchor);
                    anchor.click();
                    anchor.remove();
                    URL.revokeObjectURL(url);
                    updateStatus('PNG saved');
                }, 'image/png');
            }
        }

        exportSvgButton.addEventListener('click', () => exportScreenshot('svg'));
        exportPngButton.addEventListener('click', () => exportScreenshot('png'));

        // Drag functionality for SVG container
        let isDragging = false;
        let dragStartX = 0;
        let dragStartY = 0;
        let containerOffsetX = 0;
        let containerOffsetY = 0;

        function updateContainerPosition() {
            container.style.transform = `translate(calc(-50% + ${containerOffsetX}px), calc(-50% + ${containerOffsetY}px))`;
        }

        container.addEventListener('mousedown', (e) => {
            if (e.target === container || e.target.closest('svg')) {
                isDragging = true;
                container.classList.add('dragging');
                dragStartX = e.clientX - containerOffsetX;
                dragStartY = e.clientY - containerOffsetY;
                e.preventDefault();
            }
        });

        document.addEventListener('mousemove', (e) => {
            if (isDragging) {
                containerOffsetX = e.clientX - dragStartX;
                containerOffsetY = e.clientY - dragStartY;
                updateContainerPosition();
            }
        });

        document.addEventListener('mouseup', () => {
            if (isDragging) {
                isDragging = false;
                container.classList.remove('dragging');
            }
        });

        // Touch support
        container.addEventListener('touchstart', (e) => {
            if (e.target === container || e.target.closest('svg')) {
                isDragging = true;
                container.classList.add('dragging');
                const touch = e.touches[0];
                dragStartX = touch.clientX - containerOffsetX;
                dragStartY = touch.clientY - containerOffsetY;
                e.preventDefault();
            }
        });

        document.addEventListener('touchmove', (e) => {
            if (isDragging) {
                const touch = e.touches[0];
                containerOffsetX = touch.clientX - dragStartX;
                containerOffsetY = touch.clientY - dragStartY;
                updateContainerPosition();
                e.preventDefault();
            }
        });

        document.addEventListener('touchend', () => {
            if (isDragging) {
                isDragging = false;
                container.classList.remove('dragging');
            }
        });

        // Initialize
        loadSVG(currentSelectedSvg).then(() => {
            startAnimation();
            // Ensure studio mark has correct color on initial load
            updatePageBackgroundForVectorColor(vectorColorSelect.value);
        });
    </script>
</body>

</html>

